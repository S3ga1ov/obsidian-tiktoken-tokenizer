/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// wasm-binary:C:\Users\s3ga1\OneDrive\Документы\Obsidian\.obsidian\plugins\obsidian-sample-plugin\node_modules\@dqbd\tiktoken\tiktoken_bg.wasm
var require_tiktoken_bg = __commonJS({
  "wasm-binary:C:\\Users\\s3ga1\\OneDrive\\\u0414\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u044B\\Obsidian\\.obsidian\\plugins\\obsidian-sample-plugin\\node_modules\\@dqbd\\tiktoken\\tiktoken_bg.wasm"() {
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TiktokenTokenizerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// wasm-stub:C:\Users\s3ga1\OneDrive\Документы\Obsidian\.obsidian\plugins\obsidian-sample-plugin\node_modules\@dqbd\tiktoken\tiktoken_bg.wasm
var tiktoken_bg_exports = {};
__export(tiktoken_bg_exports, {
  default: () => import_tiktoken_bg.default,
  exportNames: () => exportNames
});
var import_tiktoken_bg = __toESM(require_tiktoken_bg());
var exportNames = void 0;

// node_modules/@dqbd/tiktoken/tiktoken_bg.js
var tiktoken_bg_exports2 = {};
__export(tiktoken_bg_exports2, {
  Tiktoken: () => Tiktoken,
  __wbg_parse_def2e24ef1252aff: () => __wbg_parse_def2e24ef1252aff,
  __wbg_set_wasm: () => __wbg_set_wasm,
  __wbg_stringify_f7ed6987935b4a24: () => __wbg_stringify_f7ed6987935b4a24,
  __wbindgen_error_new: () => __wbindgen_error_new,
  __wbindgen_is_undefined: () => __wbindgen_is_undefined,
  __wbindgen_object_drop_ref: () => __wbindgen_object_drop_ref,
  __wbindgen_string_get: () => __wbindgen_string_get,
  __wbindgen_throw: () => __wbindgen_throw,
  encoding_for_model: () => encoding_for_model,
  get_encoding: () => get_encoding
});
var wasm2;
function __wbg_set_wasm(val) {
  wasm2 = val;
}
var lTextDecoder = typeof TextDecoder === "undefined" ? (0, module.require)("util").TextDecoder : TextDecoder;
var cachedTextDecoder = new lTextDecoder("utf-8", { ignoreBOM: true, fatal: true });
cachedTextDecoder.decode();
var cachedUint8ArrayMemory0 = null;
function getUint8ArrayMemory0() {
  if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {
    cachedUint8ArrayMemory0 = new Uint8Array(wasm2.memory.buffer);
  }
  return cachedUint8ArrayMemory0;
}
function getStringFromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));
}
var heap = new Array(128).fill(void 0);
heap.push(void 0, null, true, false);
var heap_next = heap.length;
function addHeapObject(obj) {
  if (heap_next === heap.length)
    heap.push(heap.length + 1);
  const idx = heap_next;
  heap_next = heap[idx];
  heap[idx] = obj;
  return idx;
}
function handleError(f, args) {
  try {
    return f.apply(this, args);
  } catch (e) {
    wasm2.__wbindgen_export_0(addHeapObject(e));
  }
}
function getObject(idx) {
  return heap[idx];
}
function dropObject(idx) {
  if (idx < 132)
    return;
  heap[idx] = heap_next;
  heap_next = idx;
}
function takeObject(idx) {
  const ret = getObject(idx);
  dropObject(idx);
  return ret;
}
var WASM_VECTOR_LEN = 0;
var lTextEncoder = typeof TextEncoder === "undefined" ? (0, module.require)("util").TextEncoder : TextEncoder;
var cachedTextEncoder = new lTextEncoder("utf-8");
var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
  return cachedTextEncoder.encodeInto(arg, view);
} : function(arg, view) {
  const buf = cachedTextEncoder.encode(arg);
  view.set(buf);
  return {
    read: arg.length,
    written: buf.length
  };
};
function passStringToWasm0(arg, malloc, realloc) {
  if (realloc === void 0) {
    const buf = cachedTextEncoder.encode(arg);
    const ptr2 = malloc(buf.length, 1) >>> 0;
    getUint8ArrayMemory0().subarray(ptr2, ptr2 + buf.length).set(buf);
    WASM_VECTOR_LEN = buf.length;
    return ptr2;
  }
  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;
  const mem = getUint8ArrayMemory0();
  let offset = 0;
  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 127)
      break;
    mem[ptr + offset] = code;
  }
  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8ArrayMemory0().subarray(ptr + offset, ptr + len);
    const ret = encodeString(arg, view);
    offset += ret.written;
    ptr = realloc(ptr, len, offset, 1) >>> 0;
  }
  WASM_VECTOR_LEN = offset;
  return ptr;
}
function isLikeNone(x) {
  return x === void 0 || x === null;
}
var cachedDataViewMemory0 = null;
function getDataViewMemory0() {
  if (cachedDataViewMemory0 === null || cachedDataViewMemory0.buffer.detached === true || cachedDataViewMemory0.buffer.detached === void 0 && cachedDataViewMemory0.buffer !== wasm2.memory.buffer) {
    cachedDataViewMemory0 = new DataView(wasm2.memory.buffer);
  }
  return cachedDataViewMemory0;
}
var cachedUint32ArrayMemory0 = null;
function getUint32ArrayMemory0() {
  if (cachedUint32ArrayMemory0 === null || cachedUint32ArrayMemory0.byteLength === 0) {
    cachedUint32ArrayMemory0 = new Uint32Array(wasm2.memory.buffer);
  }
  return cachedUint32ArrayMemory0;
}
function getArrayU32FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint32ArrayMemory0().subarray(ptr / 4, ptr / 4 + len);
}
function passArray8ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 1, 1) >>> 0;
  getUint8ArrayMemory0().set(arg, ptr / 1);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
function passArray32ToWasm0(arg, malloc) {
  const ptr = malloc(arg.length * 4, 4) >>> 0;
  getUint32ArrayMemory0().set(arg, ptr / 4);
  WASM_VECTOR_LEN = arg.length;
  return ptr;
}
function getArrayU8FromWasm0(ptr, len) {
  ptr = ptr >>> 0;
  return getUint8ArrayMemory0().subarray(ptr / 1, ptr / 1 + len);
}
function get_encoding(encoding, extend_special_tokens) {
  if (wasm2 == null)
    throw new Error("tiktoken: WASM binary has not been propery initialized.");
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(encoding, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN;
    wasm2.get_encoding(retptr, ptr0, len0, addHeapObject(extend_special_tokens));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return Tiktoken.__wrap(r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
function encoding_for_model(model, extend_special_tokens) {
  if (wasm2 == null)
    throw new Error("tiktoken: WASM binary has not been propery initialized.");
  try {
    const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0(model, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN;
    wasm2.encoding_for_model(retptr, ptr0, len0, addHeapObject(extend_special_tokens));
    var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
    var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
    var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
    if (r2) {
      throw takeObject(r1);
    }
    return Tiktoken.__wrap(r0);
  } finally {
    wasm2.__wbindgen_add_to_stack_pointer(16);
  }
}
var TiktokenFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
}, unregister: () => {
} } : new FinalizationRegistry((ptr) => wasm2.__wbg_tiktoken_free(ptr >>> 0, 1));
var Tiktoken = class {
  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Tiktoken.prototype);
    obj.__wbg_ptr = ptr;
    TiktokenFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }
  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TiktokenFinalization.unregister(this);
    return ptr;
  }
  free() {
    if (wasm2 == null)
      throw new Error("tiktoken: WASM binary has not been propery initialized.");
    const ptr = this.__destroy_into_raw();
    wasm2.__wbg_tiktoken_free(ptr, 0);
  }
  /**
   * @param {string} tiktoken_bfe
   * @param {any} special_tokens
   * @param {string} pat_str
   */
  constructor(tiktoken_bfe, special_tokens, pat_str) {
    if (wasm2 == null)
      throw new Error("tiktoken: WASM binary has not been propery initialized.");
    const ptr0 = passStringToWasm0(tiktoken_bfe, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
    const len0 = WASM_VECTOR_LEN;
    const ptr1 = passStringToWasm0(pat_str, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
    const len1 = WASM_VECTOR_LEN;
    const ret = wasm2.tiktoken_new(ptr0, len0, addHeapObject(special_tokens), ptr1, len1);
    this.__wbg_ptr = ret >>> 0;
    TiktokenFinalization.register(this, this.__wbg_ptr, this);
    return this;
  }
  /**
   * @returns {string | undefined}
   */
  get name() {
    try {
      const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
      wasm2.tiktoken_name(retptr, this.__wbg_ptr);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      let v1;
      if (r0 !== 0) {
        v1 = getStringFromWasm0(r0, r1).slice();
        wasm2.__wbindgen_export_3(r0, r1 * 1, 1);
      }
      return v1;
    } finally {
      wasm2.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} text
   * @param {any} allowed_special
   * @param {any} disallowed_special
   * @returns {Uint32Array}
   */
  encode(text, allowed_special, disallowed_special) {
    if (wasm2 == null)
      throw new Error("tiktoken: WASM binary has not been propery initialized.");
    try {
      const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(text, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
      const len0 = WASM_VECTOR_LEN;
      wasm2.tiktoken_encode(retptr, this.__wbg_ptr, ptr0, len0, addHeapObject(allowed_special), addHeapObject(disallowed_special));
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      var r3 = getDataViewMemory0().getInt32(retptr + 4 * 3, true);
      if (r3) {
        throw takeObject(r2);
      }
      var v2 = getArrayU32FromWasm0(r0, r1).slice();
      wasm2.__wbindgen_export_3(r0, r1 * 4, 4);
      return v2;
    } finally {
      wasm2.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} text
   * @returns {Uint32Array}
   */
  encode_ordinary(text) {
    if (wasm2 == null)
      throw new Error("tiktoken: WASM binary has not been propery initialized.");
    try {
      const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(text, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
      const len0 = WASM_VECTOR_LEN;
      wasm2.tiktoken_encode_ordinary(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var v2 = getArrayU32FromWasm0(r0, r1).slice();
      wasm2.__wbindgen_export_3(r0, r1 * 4, 4);
      return v2;
    } finally {
      wasm2.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} text
   * @param {any} allowed_special
   * @param {any} disallowed_special
   * @returns {any}
   */
  encode_with_unstable(text, allowed_special, disallowed_special) {
    if (wasm2 == null)
      throw new Error("tiktoken: WASM binary has not been propery initialized.");
    try {
      const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0(text, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
      const len0 = WASM_VECTOR_LEN;
      wasm2.tiktoken_encode_with_unstable(retptr, this.__wbg_ptr, ptr0, len0, addHeapObject(allowed_special), addHeapObject(disallowed_special));
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var r2 = getDataViewMemory0().getInt32(retptr + 4 * 2, true);
      if (r2) {
        throw takeObject(r1);
      }
      return takeObject(r0);
    } finally {
      wasm2.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {number}
   */
  encode_single_token(bytes) {
    if (wasm2 == null)
      throw new Error("tiktoken: WASM binary has not been propery initialized.");
    const ptr0 = passArray8ToWasm0(bytes, wasm2.__wbindgen_export_1);
    const len0 = WASM_VECTOR_LEN;
    const ret = wasm2.tiktoken_encode_single_token(this.__wbg_ptr, ptr0, len0);
    return ret >>> 0;
  }
  /**
   * @param {Uint32Array} tokens
   * @returns {Uint8Array}
   */
  decode(tokens) {
    if (wasm2 == null)
      throw new Error("tiktoken: WASM binary has not been propery initialized.");
    try {
      const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray32ToWasm0(tokens, wasm2.__wbindgen_export_1);
      const len0 = WASM_VECTOR_LEN;
      wasm2.tiktoken_decode(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var v2 = getArrayU8FromWasm0(r0, r1).slice();
      wasm2.__wbindgen_export_3(r0, r1 * 1, 1);
      return v2;
    } finally {
      wasm2.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {number} token
   * @returns {Uint8Array}
   */
  decode_single_token_bytes(token) {
    if (wasm2 == null)
      throw new Error("tiktoken: WASM binary has not been propery initialized.");
    try {
      const retptr = wasm2.__wbindgen_add_to_stack_pointer(-16);
      wasm2.tiktoken_decode_single_token_bytes(retptr, this.__wbg_ptr, token);
      var r0 = getDataViewMemory0().getInt32(retptr + 4 * 0, true);
      var r1 = getDataViewMemory0().getInt32(retptr + 4 * 1, true);
      var v1 = getArrayU8FromWasm0(r0, r1).slice();
      wasm2.__wbindgen_export_3(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm2.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {any}
   */
  token_byte_values() {
    if (wasm2 == null)
      throw new Error("tiktoken: WASM binary has not been propery initialized.");
    const ret = wasm2.tiktoken_token_byte_values(this.__wbg_ptr);
    return takeObject(ret);
  }
};
function __wbg_parse_def2e24ef1252aff() {
  return handleError(function(arg0, arg1) {
    const ret = JSON.parse(getStringFromWasm0(arg0, arg1));
    return addHeapObject(ret);
  }, arguments);
}
function __wbg_stringify_f7ed6987935b4a24() {
  return handleError(function(arg0) {
    const ret = JSON.stringify(getObject(arg0));
    return addHeapObject(ret);
  }, arguments);
}
function __wbindgen_error_new(arg0, arg1) {
  const ret = new Error(getStringFromWasm0(arg0, arg1));
  return addHeapObject(ret);
}
function __wbindgen_is_undefined(arg0) {
  const ret = getObject(arg0) === void 0;
  return ret;
}
function __wbindgen_object_drop_ref(arg0) {
  takeObject(arg0);
}
function __wbindgen_string_get(arg0, arg1) {
  if (wasm2 == null)
    throw new Error("tiktoken: WASM binary has not been propery initialized.");
  const obj = getObject(arg1);
  const ret = typeof obj === "string" ? obj : void 0;
  var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm2.__wbindgen_export_1, wasm2.__wbindgen_export_2);
  var len1 = WASM_VECTOR_LEN;
  getDataViewMemory0().setInt32(arg0 + 4 * 1, len1, true);
  getDataViewMemory0().setInt32(arg0 + 4 * 0, ptr1, true);
}
function __wbindgen_throw(arg0, arg1) {
  throw new Error(getStringFromWasm0(arg0, arg1));
}

// node_modules/@dqbd/tiktoken/tiktoken.js
__wbg_set_wasm(tiktoken_bg_exports);

// node_modules/@dqbd/tiktoken/init.js
var isInitialized = false;
async function init(callback) {
  if (isInitialized)
    return tiktoken_bg_exports2;
  const result = await callback({ "./tiktoken_bg.js": tiktoken_bg_exports2 });
  const instance = "instance" in result && result.instance instanceof WebAssembly.Instance ? result.instance : result instanceof WebAssembly.Instance ? result : null;
  if (instance == null)
    throw new Error("Missing instance");
  __wbg_set_wasm(instance.exports);
  isInitialized = true;
  return tiktoken_bg_exports2;
}

// main.ts
var fs = __toESM(require("fs/promises"));
var TiktokenTokenizerPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.enc = null;
    this.initialized = false;
  }
  async onload() {
    this.statusBarItemEl = this.addStatusBarItem();
    this.statusBarItemEl.setText("Initializing tokenizer...");
    try {
      const wasmPath = `${this.app.vault.adapter.getBasePath()}/${this.manifest.dir}/tiktoken_bg.wasm`;
      const wasmBuffer = await fs.readFile(wasmPath);
      await init((imports) => WebAssembly.instantiate(wasmBuffer, imports));
      this.enc = get_encoding("o200k_base");
      this.initialized = true;
      this.statusBarItemEl.setText("Tokenizer ready.");
      console.log("Tiktoken tokenizer initialized successfully.");
      this.updateTokenCount();
    } catch (e) {
      console.error("Fatal error initializing Tiktoken tokenizer:", e);
      this.statusBarItemEl.setText("Tokenizer failed to load.");
      return;
    }
    this.registerEvent(this.app.workspace.on("editor-change", () => this.updateTokenCount()));
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => this.updateTokenCount()));
  }
  updateTokenCount() {
    if (!this.initialized || !this.enc) {
      return;
    }
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (view && view.editor) {
      const text = view.editor.getValue();
      try {
        const tokenCount = this.enc.encode(text).length;
        this.statusBarItemEl.setText(`Tokens: ${tokenCount}`);
      } catch (e) {
        console.error("Error counting tokens:", e);
        this.statusBarItemEl.setText("Token count error");
      }
    } else {
      this.statusBarItemEl.setText("");
    }
  }
  onunload() {
    this.enc?.free();
    this.initialized = false;
    console.log("Tiktoken tokenizer unloaded and resources freed.");
  }
};
